---
title: "Jails: confining the omnipotent root"
tags: [theory, jails, freebsd, container]
---

### Preamble
Recently I became nostalgic and fascinated with stuff from the past, so I decided to create a [Vagrantfile](https://github.com/made2591/vagrant-freebsd) to work with FreeBSD[^fbsd]. Why FreeBSD? Because as a developer, I really like Docker (who doesn't like it - just kidding: [this guy](https://dzone.com/articles/docker-is-dead)) but as a computer scientist I missed the born of Docker - I mean, historical birth: in fact, I recently realized that if Docker exist today I think it is also because of Poul-Henning Kamp[^phk]. Starting from [its work](http://phk.freebsd.dk/pubs/sane2000-jail.pdf) and using a FreeBSD installation I did some experiments with jails, what they really are, how they works, how can you create your own jail and why you should use them in a FreeBSD environment - at least, to learn something new.

<p align="center"><img src="https://i.ndtvimg.com/i/2016-03/jail-generic_650x400_81459239226.jpg" style="width: 100%; marker-top: -10px;"/></p>

### Introduction
As P.H. Kamp says in its work, _FreeBSD's __jail__ facility provides the ability to partition the operating system environment, while maintaining the simplicity of the UNIX root model_. I think its work is really clear, and I would like to follow logic steps behind its reasoning, but...wait: let's start from the problem.

#### Traditional UNIX Security
The traditional UNIX access model assigns numeric uids to each user of the system. For the purposes of human convenience, uid 0 is canonically allocated to the root user. The system can discover whether special privileges are accorded to a process simply by looking at the uid of the process: if it is equal to 0, then the process is acting with super-user privileges. Formally, let:
- $$\{root, u_1, u_2\} \in \cal U$$ respectively the root ($$uid \; = \; 0$$), and two common users $$\{uids \; = \; 1,2\}$$ from the set of users $$\cal U$$;
- $$\{p_1, p_2, p_3, p_4\} \in \cal P \in \cal O$$ four different privileged operations from the subset of privileged operations $$\cal P$$ included in the set of all available operations $$\cal O$$;
- $$G \; = \; \{V, E\}$$ a graph of _dependencies_ between operations, with $$V = \cal U$$ and $$E = \{p_1 \rightarrow p_3, p_2 \rightarrow p_3, ...\}$$;

The last is to say that many privileged operations in UNIX _seem_ independent, but are closely related and the handing out of one privilege may, in effect, be transitive to the many others. What does it means? It means that, if you have to assign different permits over the same operating system, some securelevel mechanism has to be implemented which allows the administrator to block certain configuration and management functions from being performed by root.

Cool but...first, if root is compromised, you're f\*\*\*d up, and second, having a single administrative account is not a good idea, even in the simplest environment. There are some features in _BSD_ system that provides - let me say - security capabilities: for instance, the single-user mode available to block certain functions until reboot. This is a great functionality but, it's not a solution yet to separate several root abilities. A simplest solution should be introducing new security features to split f often involves introducing new security management APIs. Further, when fine-grained capabilities are introduced to replace the setuid mechanism in UNIX-like operating systems, applications that previously did a check to see if they were running as root before executing __must now be changed__ to know that they need not run as root. This is not a real solution. If you're thinking about the chroot utility, this can be used to change the root directory of a set of processes, creating a safe and separate environment from the rest of the system: processes created in the chroot environment can not access files or resources out of this. Jails improve the concept of the traditional chroot environment in many ways. 

#### Traditional UNIX Security
In a traditional chroot environment, processes are limited only to the portion of file systems that can be accessed. The rest of system resources (such as the set of system users, running processes, or network sub-system) are shared by chrooted processes and host system processes (those not in a chroot environment). The jails expand this model by _virtualizing_ not only the file system access, but also the set of users, the FreeBSD kernel network sub-system and some other things.

#### What a jail is made of
A jail is characterized by four elements:

- A sub-branch of a directory - the starting point from which you enter the jail. Once inside the jail, a process is not allowed to exit this sub-branch. The traditional security issues affecting the original chroot (2) design do not affect FreeBSD jails.

- A hostname - the hostname that will be used inside the jail. Jails are mainly used to host network services, so having a descriptive host name for each jail can really help the system administrator.

- An IP address - this will be assigned to the jail and can not be changed in any way during the life of the jail. The IP address of a jail is usually an alias address of an existing network interface, although this is not strictly necessary.

- A command - the path to an executable to start inside the jail. This is relative to the root directory of the jail environment, and can vary a lot, depending on the specific type of jail environment.

#### Jail 
Jail permits to partition a FreeBSD environment (processes, file system, network resources) into a management environment, and optionally subset Jail environments. The administrator of a FreeBSD machine can partition the machine into separate jail and provide access to the super-user account in each of these without losing control of the over-all environment.

[^phk]: [Poul-Henning Kamp](https://en.wikipedia.org/wiki/Poul-Henning_Kamp)
[^fbsd]: [https://www.freebsd.org/it/](https://www.freebsd.org/it/)