---
title: "A journey through the network - Hands on"
tags: [theory, network, iso/osi, tcp/ip, saga]
---

### A journey through the network - Hands on
A long long time ago ([*I can still remember*](https://www.youtube.com/watch?v=uxYpS_bVdhk) as Madonna sings) I started to wrote some posts about the network. For those who missed the previous posts, [the introduction](https://madeddu.xyz/posts/network-layers-0), [the physycal layer](https://madeddu.xyz/posts/network-layers-1) and [the datalink layer](https://madeddu.xyz/posts/network-layers-2). For the previous post I had to go into details about how some parts of the physical layer work but, by going forward with the layers, concepts belonging to separate historical standards - OSI and IP - will intertwine and this entails some troubles from a _logical_ point of view.
As a main source I use [Computer Networks](https://www.amazon.it/gp/product/9332518742/ref=oh_aui_detailpage_o01_s00?ie=UTF8&psc=1) and [TCP/IP Illustrated](https://www.amazon.it/gp/product/9332535957/ref=oh_aui_detailpage_o02_s00?ie=UTF8&psc=1). In this article, I want to speak more about facts, or how the things really works - at list, what I understood. Enjoy the reading!

### First recap
Just to be completly transparent, this is a summary table with some mapping between what happens and to which levels things happening belongs to, with some example.

| OSI Ref. Layer No. | OSI Layer Equivalent               | TCP/IP Layer     | TCP/IP Protocol Examples                                                         |
|--------------------|------------------------------------|------------------|----------------------------------------------------------------------------------|
| 5,6,7              | Application, session, presentation | Application      | NFS, NIS, DNS, LDAP, telnet, ftp, rlogin, rsh, rcp, RIP, RDISC, SNMP, and others |
| 4                  | Transport                          | Transport        | TCP, UDP, SCTP                                                                   |
| 3                  | Network                            | Internet         | IPv4, IPv6, ARP, ICMP                                                            |
| 2                  | Data link                          | Data link        | PPP, IEEE 802.2                                                                  |
| 1                  | Physical                           | Physical network | Ethernet (IEEE 802.3), Token Ring, RS-232, FDDI, and others                      |

Useless?

### Learn by doing: top down approach
There's no better way than try by yourself thus let's try. As almost always in Computer Science, there are two ways of doing things: top down and bottom up. Since until now I moved bottom up, let's try this time going top down.

### curl
Open a shell and write down the following:

{% highlight sh %}
curl https://www.google.com
{% endhighlight %}

What does this command mean? Well, let's start from the ```curl```. Directly from the man page:

> curl is a tool to transfer data from or to a server, using one of the supported protocols (DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET and TFTP). The command is designed to work without user interaction. curl offers a busload of useful tricks like proxy support, user authentication, FTP upload, HTTP post, SSL connections, cookies, file transfer resume, Metalink, and more. As you will see below, the number of features will make your head spin. curl is powered by libcurl for all transfer-related features. See libcurl(3) for details.

#### libcurl
What the *f\*\*k* is this ```libcurl```? Directly from Internet:

> libcurl is a free and easy-to-use client-side URL transfer library, supporting [..], is highly portable, it builds and works identically on numerous platforms, including [..], is free, thread-safe, IPv6 compatible, feature rich, well supported, fast, thoroughly documented and is already used by many known, big and successful companies.

So, it's a package man. curl use it: yes but what does it mean? Well, since there are plenty of nice community in the world, developers that mantain actively encourage users to first try out the transfer they want to do with the curl command-line tool, and once it works roughly the way you want it to, you append the --libcurl [filename] option to the command line and run it again. Thus let's do it cause it's exactly what we want to achieve

{% highlight sh %}
curl https://www.google.com --libcurl google.c
{% endhighlight %}

and we obtain a code like

{% highlight c %}
/********* Sample code generated by the curl command line tool **********
 * All curl_easy_setopt() options are documented at:
 * https://curl.haxx.se/libcurl/c/curl_easy_setopt.html
 ************************************************************************/
#include <curl/curl.h>

int main(int argc, char *argv[])
{
  CURLcode ret;
  CURL *hnd;

  hnd = curl_easy_init();
  curl_easy_setopt(hnd, CURLOPT_URL, "https://www.google.com");
  curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);
  curl_easy_setopt(hnd, CURLOPT_USERAGENT, "curl/7.54.0");
  curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);
  curl_easy_setopt(hnd, CURLOPT_HTTP_VERSION, (long)CURL_HTTP_VERSION_2TLS);
  curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);

  /* Here is a list of options the curl code used that cannot get generated
     as source easily. You may select to either not use them or implement
     them yourself.

  CURLOPT_WRITEDATA set to a objectpointer
  CURLOPT_INTERLEAVEDATA set to a objectpointer
  CURLOPT_WRITEFUNCTION set to a functionpointer
  CURLOPT_READDATA set to a objectpointer
  CURLOPT_READFUNCTION set to a functionpointer
  CURLOPT_SEEKDATA set to a objectpointer
  CURLOPT_SEEKFUNCTION set to a functionpointer
  CURLOPT_ERRORBUFFER set to a objectpointer
  CURLOPT_STDERR set to a objectpointer
  CURLOPT_HEADERFUNCTION set to a functionpointer
  CURLOPT_HEADERDATA set to a objectpointer

  */

  ret = curl_easy_perform(hnd);

  curl_easy_cleanup(hnd);
  hnd = NULL;

  return (int)ret;
}
/**** End of sample code ****/
{% endhighlight %}

This are the operations accomplished by the CURL command. Let's see them in details:

- ```curl_easy_setopt``` is used to tell libcurl how to behave. By setting the appropriate options, the application can change libcurl's behavior. All options are set with an option followed by a parameter. It is called many times with different parameters.
  - ```CURLOPT_URL```: this is the URL to work on. CURLOPT_NOPROGRESS switch off the progress meter;
  - ```CURLOPT_USERAGENT```: User-Agent: header. More on this later;
  - ```CURLOPT_MAXREDIRS```: Maximum number of redirects to follow. The set number will be the redirection limit amount. If that many redirections have been followed, the next redirect will cause an error;
  - ```CURLOPT_HTTP_VERSION```: HTTP version to use. Normally you want to use the default;
  - ```CURLOPT_TCP_KEEPALIVE```: Enable TCP keep-alive. If set to 1, TCP keepalive probes will be sent. The delay and frequency of these probes can be controlled by the CURLOPT_TCP_KEEPIDLE and CURLOPT_TCP_KEEPINTVL options, provided the operating system supports them. Set to 0 (default behavior) to disable keepalive probes. More on this later;

Then, there are plenty of things we really don't know how they works. Fortunately, there are open sources thus we can go through them:

#### The functions under the hood
Let's go through rough implementation of the function and what is is expected.

##### CURLOPT_WRITEDATA
This is a data pointer to pass to the write callback. If you use the ```CURLOPT_WRITEFUNCTION``` option, this is the pointer you'll get in that callback's 4th argument. If you don't use a write callback, you must make pointer a 'FILE *' (cast to 'void *') as libcurl will pass this to fwrite(3) when writing data. The internal ```CURLOPT_WRITEFUNCTION``` will write the data to the FILE * given with this option, or to stdout if this option hasn't been set.

Clear enough? It couldn't be because we don't know what ```CURLOPT_WRITEFUNCTION``` is, even if the name some how provide a suggestion to us... but ehy! Let's have a look at it.

##### The CURLOPT_WRITEFUNCTION in the curl

{% highlight c %}
#include <curl/curl.h>
...
// some CURL code
...
curl_easy_setopt(CURL *handle, CURLOPT_WRITEFUNCTION, write_callback);
{% endhighlight %}

when the write_callback has to match the following signature:

{% highlight c %}
size_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata);
{% endhighlight %}

Thus, this parameter is intended to pass a pointer to your callback function, which should match the prototype shown above. This callback function gets called by libcurl as soon as there is data received that needs to be saved. For most transfers, this callback gets called many times and each invoke delivers another chunk of data. ptr points to the delivered data, and the size of that data is nmemb; size is always 1.

The callback function will be passed as much data as possible in all invokes, but you must not make any assumptions. It may be one byte, it may be thousands. The maximum amount of body data that will be passed to the write callback is defined in the curl.h header file: ```CURL_MAX_WRITE_SIZE``` (the usual default is 16K). If ```CURLOPT_HEADER``` is enabled, which makes header data get passed to the write callback, you can get up to ```CURL_MAX_HTTP_HEADER``` bytes of header data passed into it. This usually means 100K.

This function may be called with zero bytes data if the transferred file is empty. The data passed to this function will not be zero terminated!

Set the userdata argument with the ```CURLOPT_WRITEDATA``` option. Set this option to NULL to get the internal default function used instead of your callback. The internal default function will write the data to the ```FILE``` * given with ```CURLOPT_WRITEDATA```. Which function the libcurl use by default? The simple ```fwrite()``` that is ok because...

{% highlight c %}
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)
{% endhighlight %}

with:
- ptr: this is the pointer to the array of elements to be written.
- size: this is the size in bytes of each element to be written.
- nmemb: this is the number of elements, each one with a size of size bytes.
- stream: this is the pointer to a FILE object that specifies an output stream.

It respects precisely the one wanted by the library.

##### CURLOPT_INTERLEAVEDATA
Data pointer to pass to the RTSP interleave callback. This is the userdata pointer that will be passed to ```CURLOPT_INTERLEAVEFUNCTION``` when interleaved RTP data is received. If the interleave function callback is not set, this pointer is not used anywhere. Ok this is advanced but it's the first time we are encountering something from our tables. RTP is in fact an application layer protocol that relies on UDP - from the transport layer. We don't have to go into details about it because our request's doesn't use protocols.

##### CURLOPT_WRITEFUNCTION
We already spoke about that. Let's go ahead with the **READ** part.

##### CURLOPT_WRITEDATA
This is a data pointer to pass to the file read function. If you use the ```CURLOPT_READFUNCTION``` option, this is the pointer you'll get as input in the 4th argument to the callback. If you don't specify a read callback but instead rely on the default internal read function, this data must be a valid readable FILE * (cast to 'void *').

Clear enough? It couldn't be because we don't know what ```CURLOPT_READFUNCTION``` is, even if the name some how provide a suggestion to us... but ehy! Let's have a look at it.

##### CURLOPT_READFUNCTION
{% highlight c %}
#include <curl/curl.h>
...
// some CURL code
...
curl_easy_setopt(CURL *handle, CURLOPT_READFUNCTION, read_callback);
{% endhighlight %}

when the read_callback has to match the following signature:

{% highlight c %}
size_t read_callback(char *buffer, size_t size, size_t nitems, void *userdata);
{% endhighlight %}

This callback function gets called by libcurl as soon as it needs to read data in order to send it to the peer - like if you ask it to upload or post data to the server. The data area pointed at by the pointer buffer should be filled up with at most size multiplied with nitems number of bytes by your function.

Set the userdata argument with the ```CURLOPT_READDATA``` option.

Your function must return the actual number of bytes that it stored in the data area pointed at by the pointer buffer. Returning 0 will signal end-of-file to the library and cause it to stop the current transfer.

If you stop the current transfer by returning 0 "pre-maturely" (i.e. before the server expected it, like when you've said you will upload N bytes and you upload less than N bytes), you may experience that the server "hangs" waiting for the rest of the data that won't come.

The read callback may return ```CURL_READFUNC_ABORT``` to stop the current operation immediately, resulting in a ```CURLE_ABORTED_BY_CALLBACK``` error code from the transfer. The callback can return ```CURL_READFUNC_PAUSE``` to cause reading from this connection to pause. If you set this callback pointer to NULL, or don't set it at all, the default internal read function will be used. Which function the libcurl use by default? It is doing an ```fread()``` on the FILE * userdata set with ```CURLOPT_READDATA```.

Again... of course ```fread()``` respects the signature otherwise wouldn't work.

##### CURLOPT_SEEKDATA
Data pointer to pass to the seek callback function. If you use the ```CURLOPT_SEEKFUNCTION``` option, this is the pointer you'll get as input.

##### AND YES CURLOPT_SEEKFUNCTION.... it's THAT SEEK you remember from school
Pass a pointer to your callback function, which should match the prototype shown above. This function gets called by libcurl to seek to a certain position in the input stream and can be used to fast forward a file in a resumed upload (instead of reading all uploaded bytes with the normal read function/callback). It is also called to rewind a stream when data has already been sent to the server and needs to be sent again. This may happen when doing an HTTP PUT or POST with a multi-pass authentication method, or when an existing HTTP connection is reused too late and the server closes the connection. The function shall work like ```fseek()``` or ```lseek()``` and it gets ```SEEK_SET```, ```SEEK_CUR``` or ```SEEK_END``` as argument for origin, although libcurl currently only passes ```SEEK_SET```.

##### CURLOPT_ERRORBUFFER, CURLOPT_STDERR, CURLOPT_HEADERFUNCTION, CURLOPT_HEADERDATA
Ok you got the idea about how that code is implemented.

### Let's implement this function



You typically type an web address (Uniform resource locator) in a Web browser. Web browser uses something called  Hypertext Transfer Protocol which is an Application layer protocol.

