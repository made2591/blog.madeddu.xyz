<!DOCTYPE html>
<html>
  <head>
    <!-- Google Tag Manager -->
    <!--<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-M8WBXH7');</script>-->
    <!-- End Google Tag Manager -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href=/public/stylesheets/bs.css?random=@Environment.TickCount>
    <link rel="stylesheet" href=/public/stylesheets/styles.css?random=@Environment.TickCount>
    <link rel="stylesheet" href=/public/stylesheets/pygment_trac.css?random=@Environment.TickCount>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css">
    <link rel="canonical" href="made2591.github.io/posts/quantum-computing">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
      <link rel="icon" type="image/x-icon"  href="/favicon.ico" />
    <title>A Quantum Experience | Matteo Madeddu</title>
    <!--[if lt IE 9]>

      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  </head>
  <body>
    <!-- Google Tag Manager (noscript) -->
    <!--<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M8WBXH7"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div class="wrapper">
        <section>
          <div id="header">
  <h1>
    <a id="sitename" href="">Matteo Madeddu</a>
  </h1>

  <!-- Add something about you in p tag-->
  <p>Mac OS lover, Docker fan, Go explorer, Python geek, Trello addicted.</p>
  <hr/>

  <span class="credits pull-left">
    
      <a href="/">Home</a>  | 
    
      <a href="/blog">Blog</a>  | 
    
      <a href="/archive">Archive</a>  | 
    
      <a href="/about">About</a>  | 
    
      <a href="/matteo_madeddu_cv.pdf">Resume</a>  | 
    
      <a href="/quotes">Quotes</a> 
    
  </span>

  <span class="credits pull-right social">
    
      
        <a href="https://github.com/made2591/" target="_blank"><i class="fa fa-github"></i></a>
      
    
      
        <a href="https://twitter.com/made2591" target="_blank"><i class="fa fa-twitter"></i></a>
      
    
      
        <a href="https://linkedin.com/in/mmadeddu" target="_blank"><i class="fa fa-linkedin"></i></a>
      
    
      
        <a href="https://www.facebook.com/matteo.madeddu" target="_blank"><i class="fa fa-facebook"></i></a>
      
    
  </span>


</div>


          <div class="post-title">
    <h1>A Quantum Experience</h1>
    <p class="text-muted">
    


    20 Feb 2018
    
     | <i class="fa fa-comment"></i> <a class="text-muted" href="/posts/quantum-computing/#disqus_thread"></a>
    

    
      | <i class="fa fa-tag"></i>
      
        <a class="text-muted" href="/tags/#theory ">theory</a>,
      
        <a class="text-muted" href="/tags/#quantum ">quantum</a>,
      
        <a class="text-muted" href="/tags/#q ">q</a>,
      
        <a class="text-muted" href="/tags/#informative ">informative</a>,
      
        <a class="text-muted" href="/tags/#ibm ">ibm</a>
      
    
  </p>
</div>

  <h3 id="much-more-than-a-post">Much more than a post</h3>
<p>What is the quantum theory? As said by <a href="https://quantumexperience.ng.bluemix.net/">quantumexperience</a> official site by IBM, it’s <em>an elegant mathematical theory able to explain the counterintuitive behavior of subatomic particles, most notably the phenomenon of entanglement</em>. In the late twentieth century it was discovered that quantum theory applies not only to atoms and molecules, but to bits and logic operations in a computer. This realization has been bringing about a revolution in the science and technology of information processing: I decided to write some notes to better explain, from a physics-agnostic computer scientist’s point of view XD, <strong>what I understood</strong> - and it is certainly wrong - about Q until now and why I think it’s an amazing field for computer science. For skilled guys, <a href="https://github.com/made2591/quantum-notes">here</a> latex source (and <a href="https://made2591.github.io/matteo_madeddu_quantum_notes.pdf">here</a> pdf pre-compiled version) that collect my personal notes about IBM Q platform, in general the quantum-computing world. I was also invited in Verona by the Quantum Research Group of the Department of Computer Science - why? don’t know, maybe the coolest guys were sick 😂 - to talk about the platform and we had a really interesting brain-storming conversation about a quantum version of the Tris game I am working on 😎</p>

<p align="center"><img src="https://d1o50x50snmhul.cloudfront.net/wp-content/uploads/2016/05/26093923343_1a9dea0cd2_o-1200x800.jpg" style="width: 100%; marker-top: -10px;" /></p>

<h3 id="introduction">Introduction</h3>
<p>I should start by saying that my education background is in Computer Science. While I’ve read a couple of books on quantum mechanics, I don’t have formal training as a physicist: that didn’t deter me from learning the generalities about quantum mechanics and play with quantum computers. In this post, I reported an extract of my notes available <a href="">here</a></p>

<p>These notes collected everything that was useful and necessary for me to fully understand the basic concepts related to this world, with particular attention to quantum computation provided by the <code class="highlighter-rouge">IBM Q Platform</code>. They represents essentialy a work of enrichment of the material available online, with the intention of making more accessible to anyone who wants to deal with the quantum world. To help me understand more in depth the concepts introduced, I wrote some more recalls of maths using as main source the notes in this book<sup id="fnref:susskind2014quantum"><a href="#fn:susskind2014quantum" class="footnote">1</a></sup>.</p>

<h3 id="physics-and-computation">Physics and Computation</h3>
<p>A calculation process is essentially a physical process that is performed on a machine whose operation obeys certain physical laws. The
classical theory of computation is based on an abstract model of universal machine, the Universal Turing Machine, that works according to
a set of rules and principles enunciated in 1936 by Alan Turing and subsequently elaborated by John Von Neumann in the 1940s. These
principles have remained essentially unchanged since then, despite the enormous technological advances that today allow to produce far more
powerful devices than those that could be achieved in the first half of the twentieth century. The tacit assumption underlying these principles is that a Turing machine idealizes a mechanical computational device - with a potentially infinite memory - that obeys the laws of classical physics.</p>

<p>Usually the concept of <em>difficulty</em> is quite subjective, but for a computer scientist this word has a different meaning: the classical
information theory divides the problems that can be solved by a computer according to their complexity, i.e. the time taken by the computer to solve them according to the length of the input. Apparently, there are problems that are unsolvable, even from a computer when the dimensions of the initial parameters become relevant. For instance, it may be impossible to find the solution of a sudoku, solve the enigma of the traveling salesman or break down a number in its prime factors. However, a <em>quantum</em> computer has the ability to perform multiple operations together, i.e. by <em>quantum</em> parallelize tasks. Thus, in the XX century an unlikely alliance between physicists and computer scientist was born with the common goal of developing a quantum machine: computer scientists wanted to amply the class of problem solvable by machines and to overcome the limit of the classic Turing’s computation theory, physicists wanted to understand a little more the mysteries of quantum mechanics. As a result of this cooperation, a series of <em>quantum algorithms</em> have been structured in such a way to use a quantum phenomena such as the principle of <em>superposition</em> or <em>entanglement</em>: only by exploiting these properties properly, it’s possible to tap into all the potential of quantum computing. What makes the quantum computer so interesting?</p>

<h4 id="quantum-computation">Quantum computation</h4>
<p>Quantum computation is born as an alternative paradigm based on the principles of quantum mechanics. The idea of creating a model of computation as an isolated quantum system began to appear at the beginning of the eighties, when P. Benioff, starting from considerations
previously elaborated by C. Bennet, defined the reversible Turing Machine: a computation can always be executed in such a way as to return
to the initial state by retracing the various steps of computation backwards.</p>

<p>Subsequently R. Feynman showed that no classical Turing Machine could simulate certain physical phenomena without incurring an exponential
slowing of its performances. In contrast, a “universal quantum simulator" could have performed the simulation more efficiently.</p>

<p>In 1985 D. Deutsch formalized these ideas in his Universal Quantum Turing Machine, which in quantum computational theory represents exactly
what the Universal Turing Machine represents for classical computability and led to the modern conception of quantum computation.</p>

<p>Naturally, the effects of the introduction of the new calculation model were also felt in the field of computational complexity (as envisaged by Feynman), causing the change of the notion of “treatability". In fact, in 1994 P. Shor shows that the problem of factorization of prime numbers - classically considered intractable - can be solved efficiently, i.e. in polynomial time - with a quantum algorithm. These considerations, combined with the technological ones mentioned above, have led to the emergence of the research field known today as information theory and quantum computation. In particular, the three fundamental, and not very intuitive phenomena of the quantum theory, are the <em>principle of superposition</em> of states, the <em>principle of measurement</em> and the <em>phenomenon of entanglement</em>. To introduce them, it is necessary to introduce some concept related to the quantum world and after that some recall of mathematical algebra.</p>

<h3 id="basics">Basics</h3>
<p>I don’t want you to provide basic notions to understand quantum mechanics: you can have a look at my repo tex <a href="https://github.com/made2591/quantum-notes">here</a> and some exercises <a href="https://github.com/made2591/quantum">here</a>. If you want to find more without dive into maths details you can refers to guides: a beginner version is available <a href="https://quantumexperience.ng.bluemix.net/qx/tutorial?sectionId=beginners-guide&amp;page=introduction">here</a>. The <code class="highlighter-rouge">IBM Q</code> team makes available a real quantum computer I found really useful to understand the concepts and exercises proposed in university notes. The last section of the will contain a collection of exercises - with respective answers - exposed in university course, collected from exams draft available online and provided by several universities, proposed by the <code class="highlighter-rouge">IBM Q</code> in its tutorial cycle and some other personal circuits I coded to understand better the gates available.</p>

<h4 id="ibm-quantum-composer">IBM quantum composer</h4>
<p>The quantum composer is the official IBM graphical user interface for programming a quantum processor. The composer is a tool to construct
quantum circuits using a library of well-defined gates and measurements. You can create your own account in IBM using Github sign up starting from <a href="https://quantumexperience.ng.bluemix.net/">quantum experience</a> site.</p>

<p>When you first click on the “Composer" tab above, you will have a choice between running a real quantum processor or a custom quantum
processor. In the custom processor, gates can be placed anywhere, whereas in the real processor, the topology is set by the physical
device running in our lab (note that this restricts the usability of some of the two-qubit gates). Once you are in the “Composer" tab, you
can start making your very own quantum circuits. The IBM quantum composer is shown in</p>

<p align="center"><img src="https://github.com/made2591/quantum-notes/blob/master/images/ibmComposer.png?raw=true" style="marker-top: -10px;" /></p>

<p>With the composer, you can create a quantum score, which is analogous to a musical score in several respects. Time progresses from left to right. Each line represents a qubit (as well as what happens to that qubit over time). Each qubit has a different frequency, like a different musical note. The quantum composer’s library (located to the right of the qubit stave) contains many different classes of gates: single-qubit gates, such as the yellow idle operation; the green class of <strong>Pauli operators</strong>, which represent bit-flips (X, equivalent to a classical NOT); phase-flips (Z); and a combined bit-flip and phase-flip (Y). There are others gates available that haven’t been introduced yet. In general, quantum gates are represented by square boxes that play a frequency for different durations, amplitudes, and phases. Gates on just one line are called single-qubit gates. Before going on with esperiments, let’s introduce these kind of gates.</p>

<h4 id="ibm-q---first-experiment">IBM Q - First Experiment</h4>
<p>When you begin an experiment, you’ll be prompted to give it a name, so that you can recognize it later. You will also see two choices: real
quantum processor, or custom topology. In both cases, you create your score by dragging gates onto the stave, adding a measurement, and then hitting “run" for the score to execute. If you select “Custom Topology" your only option is to run your score in simulation. This is because the custom processor permits all-to-all connectivity; the real device, in contrast, is limited by physical connectivity. When you select custom topology, a dialogue box will ask you to select the number of qubits and classical bits assigned to different registers. IBM have set the maximum number of qubits to 20.</p>

<p>The operation
<script type="math/tex">M</script>
consists in the measurement of a qubit. If you measure, for instance,
<script type="math/tex">|\psi\rangle = \alpha|0\rangle + \beta|0\rangle</script>
you know the result is a classic bit
<script type="math/tex">M</script>
(indicated with a double line) that will be
<script type="math/tex">0</script>
or
<script type="math/tex">1</script>
with probability respectively
<script type="math/tex">{|\alpha|}^2</script>
an
<script type="math/tex">{|\beta|}^2</script>.</p>

<p>The execution of your circuit happens immediately (unless the number of qubits is large) and the output can then be viewed in the results. You can try the “single qubit measurement" show in</p>

<p align="center"><img src="https://github.com/made2591/quantum-notes/blob/master/images/ibmComposerSimpleEmulated.png?raw=true" style="marker-top: -10px;" /></p>

<p>If you have chosen a real quantum processor, the composer will look like the one shown in</p>

<p align="center"><img src="https://github.com/made2591/quantum-notes/blob/master/images/ibmComposerSimpleReal.png?raw=true" style="marker-top: -10px;" /></p>

<p>In IBM quantum experience, the results from launching your quantum scores can be visualized in two different ways: a standard histogram/bar
graph, and as a quantum sphere, or QSphere - the Block Sphere introduced before. The QSphere represents quantum circuit measurement outcomes in a visually striking and information-dense graphic.</p>

<p>After performing a quantum measurement, a qubit’s information becomes a classical bit, and in our system (as is standard) the measurements are performed in the computational basis. For each qubit the measurement either takes the value 0 if the qubit is measured in state
<script type="math/tex">|0\rangle</script>
and value
<script type="math/tex">|1\rangle</script>
if the qubit is measured in state
<script type="math/tex">|1\rangle</script>.</p>

<p>In a given run of a quantum circuit with
<script type="math/tex">n</script>
measurements, the result will be one of the
<script type="math/tex">2^n</script>
possible
<script type="math/tex">n</script>-bit binary strings. If the experiment is run a second time, even if the measurement is perfect and has no error, the outcome may be different due to the fundamental randomness of quantum physics. The results of a quantum circuit executed many different times can be represented as a distribution over the full
<script type="math/tex">2^n</script>
possible outcomes. It is not scalable to represent all possible outcomes; therefore, we keep only those outcomes that happen in a given experiment and represent them in two different ways: as bars or as a quantum sphere.</p>

<ul>
  <li>The <strong>histogram representation</strong> is the simplest to understand. The height of the bar represents the fraction of instances the outcome comes up in the different runs on the experiment. Only those outcomes that occurred with non-zero occurrences are included. If all the bars are small for visualization only (not if you download the data) they are collected into single bar called <em>other values</em>. In general this is not a problem as a good quantum circuit should not have many outcomes only circuits that have the final state in a large superposition will give many outcomes and these would take exponential measurements to measure.</li>
  <li>The <strong>quantum sphere representation</strong> (QSphere) is the IBM tool to visually show the same data as the bar graph neatly and strikingly. Each line from the center represents a possible outcome of the experiment, and the weight (darkness of the line) represents the likelihood of each outcome. As with the histogram, only those outcomes are included that occurred in a given experiment. The QSphere is divided into
<script type="math/tex">n+1</script>
levels, and each section represents the weight (total number of
<script type="math/tex">1</script>
s) of the binary outcome. The top is the
<script type="math/tex">|0\ldots0\rangle</script>
outcome, the next line is all the outcomes with a single 1 (
<script type="math/tex">|10\ldots0\rangle</script>,
<script type="math/tex">|01\ldots0\rangle</script>, etc), the line after that is all outcomes with two
<script type="math/tex">1</script>
s, and so on until the bottom that is the outcome
<script type="math/tex">|1\ldots1\rangle</script>.</li>
</ul>

<p>For a single qubit there are two outcomes, and the sphere has only two levels; for two qubits, it has three sections with the middle section separated into two parts; for three qubits, it has four sections with the middle two being broken into three sections, and so on, following Pascal’s triangle. The usefulness of the Block Sphere representation is for distinguishing classical states from entangled states. A computational basis state will have a single line pointing in one direction. Under the assumption the state is pure, a superposition of two basis states will have two lines pointing in two directions of half weight. If these directions are on opposite sides of the QSphere we have a state that is maximally entangled (for
<script type="math/tex">n>1</script>
) in the computation bases. Finally if there are faint lines in every direction we have made a uniform superposition state.</p>

<h3 id="ibm-q---testing-the-gates">IBM Q - Testing the gates</h3>
<p>The configuration to test the effect of <code class="highlighter-rouge">X</code> gate is really simple: first, drag and drop an <code class="highlighter-rouge">X</code> gate on the first qubit (first line) - time
is discrete, divided in several dots. The initial state of each qubit is
<script type="math/tex">|0\rangle</script></p>

<p>In general, an operation on a single qubit can be specified by a
<script type="math/tex">2 \times 2</script>
matrix. However, not all
<script type="math/tex">2 \times 2</script>
arrays define “legitimate" operations on qubits. We recall that the normalization condition requires that
<script type="math/tex">\alpha^{2} + \beta^{2}</script>
in any quantum state
<script type="math/tex">\alpha|0\rangle + \beta|1\rangle</script>
The same condition must also apply to the state that is obtained after carrying out the operation. The property of matrices that guarantees the transformation of a unit vector into a vector that is still unitary is unity.</p>

<p>You can try also the other Pauli operators using <code class="highlighter-rouge">Y</code> and <code class="highlighter-rouge">Z</code> gates. In the next few paragraphs, something more will be said about these two
gates.</p>

<h3 id="ibm-q---create-a-superposition">IBM Q - Create a superposition</h3>
<p>On the contrary to the classic case in which we can define a single non-trivial operation on a single bit, in the quantum case there are
many non-trivial operations on a single qubit. Besides the <code class="highlighter-rouge">NOT</code> two important operations that we will use later are the
<script type="math/tex">Z</script>
port:
<script type="math/tex">% <![CDATA[
Z = \begin{bmatrix}
1 & 0 \\
0 & -1
\end{bmatrix} %]]></script>
which only affects the
<script type="math/tex">|1\rangle</script>
component by changing
the sign, and the Hadamard gate:
<script type="math/tex">% <![CDATA[
H =\frac{1}{\sqrt{2}}\begin{bmatrix}
1 & 1 \\
1 & -1
\end{bmatrix} %]]></script>
The latter operation is one of the most useful and is very often used in the definition of quantum circuits. Its effect is that of transforming a base state into an overlap that results, after a measurement in the computational basis, to be
<script type="math/tex">0</script>
or
<script type="math/tex">1</script>
with equal probability. For example, by applying
<script type="math/tex">H</script>
to
<script type="math/tex">|0\rangle</script>
you get:
<script type="math/tex">H \begin{bmatrix}
1 \\
0 \\
\end{bmatrix} = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 \\
1 \\
\end{bmatrix}</script>
that is the state
<script type="math/tex">\frac{|0\rangle + |1\rangle}{\sqrt{2}}</script>
![Display of Hadamard port applied to input
<script type="math/tex">|0\rangle</script>: 
the output is
<script type="math/tex">|\psi\rangle = |0\rangle + |1\rangle</script></p>

<p align="center"><img src="https://github.com/made2591/quantum-notes/blob/master/images/ibmQuantumSphereHadamard.png?raw=true" style="marker-top: -10px;" /></p>

<p>The effect of
<script type="math/tex">H</script>
can therefore be seen as an <em>half-executed</em> <code class="highlighter-rouge">NOT</code>, so that the resulting state is neither
<script type="math/tex">0</script>
nor
<script type="math/tex">1</script>, but a coherent overlap of the two base states. For this reason
<script type="math/tex">H</script>
is often called the <em>square root of</em> <code class="highlighter-rouge">NOT</code>. Note that this expression has <strong>only</strong> a physical meaning! From an algebraic point of view,
<script type="math/tex">H^2</script>
is not the
<script type="math/tex">X</script>
matrix. With a simple calculation one can in fact verify that
<script type="math/tex">H^2</script>
is the identity and therefore applying
<script type="math/tex">H</script>
twice to a state leaves it unaltered. In the Bloch sphere, the
<script type="math/tex">H</script>
operation corresponds to a rotation of
<script type="math/tex">90</script>
of the sphere around the
<script type="math/tex">Y</script>
axis followed by a reflection through the plane
<script type="math/tex">(X, Z)</script>. Another way to see the rotation is to imagine it as a
<script type="math/tex">180</script>
rotation over the bisector between
<script type="math/tex">X</script>
and
<script type="math/tex">Z</script>
axis: a
<script type="math/tex">180</script>
rotation around
<script type="math/tex">X+Z</script>
swaps points on the
<script type="math/tex">X</script>
axis to the
<script type="math/tex">Z</script>
axis (and vice versa), and negates points on the
<script type="math/tex">Y</script>
axis. The shows the effect of applying
<script type="math/tex">H</script>
to qubit
<script type="math/tex">|0\rangle</script>.</p>

<p align="center"><img src="http://image.ibb.co/eWLvOH/hfig.png" alt="perceptron" style="width: 70%; marker-top: -10px;" /></p>

<p>You can try to visualize the effect of
<script type="math/tex">H</script>
on the qubit
<script type="math/tex">\frac{|0\rangle + |1\rangle}{\sqrt{2}}</script>
For effect of the rotation and subsequent reflection through the plane
<script type="math/tex">x, y</script>
you will obtain again
<script type="math/tex">|0\rangle</script>
The logic gates to a qubit
<script type="math/tex">X</script>,
<script type="math/tex">Z</script>
and
<script type="math/tex">H</script>
are represented graphically as in</p>

<p align="center"><img src="http://image.ibb.co/mzSycc/qports.png" alt="perceptron" style="width: 70%; marker-top: -10px;" /></p>

<h4 id="multiple-qubits-quantum-logic-gates">Multiple qubits quantum logic gates</h4>
<p>Operations on quantum registers of two or more qubits are necessary to describe the transformations of compound states and in particular of the <em>so-called</em> <strong>entangled states</strong>. We have seen that a two-qubit register can not always be decomposed into the tensor product of the individual qubits components. Therefore we can not in such cases simulate an operation on the two qubits through operations on each qubit component. Also operations on qubit registers correspond to unit operations as in the case of a single qubit. The most important logic gates that implement operations on two classic bits are the <code class="highlighter-rouge">AND</code>, <code class="highlighter-rouge">OR</code>, <code class="highlighter-rouge">XOR</code>, <code class="highlighter-rouge">NAND</code> and <code class="highlighter-rouge">NOR</code> ports. The <code class="highlighter-rouge">NOT</code> and <code class="highlighter-rouge">AND</code> ports form a universal set, i.e. any boolean function can be accomplished by a combination of these two operations. For the same reason, the <code class="highlighter-rouge">NAND</code> constitutes a universal whole. Note that <code class="highlighter-rouge">XOR</code> alone or even together with <code class="highlighter-rouge">NOT</code> is not universal: since it preserves the total parity of the bits, only a subset of the boolean functions can be represented by this operation. The quantum analog of <code class="highlighter-rouge">XOR</code> is the <code class="highlighter-rouge">CNOT</code> gate (controlled-<code class="highlighter-rouge">NOT</code>) which operates on two qubits: the first is called the control qubit and the second is the qubit target. The <code class="highlighter-rouge">CNOT</code> gate is graphically represented by the circuit in</p>

<p align="center"><img src="http://image.ibb.co/itUYAx/cnot.png" alt="perceptron" style="width: 40%; marker-top: -10px;" /></p>

<p>If the control is zero then the target is left unchanged; if the control is one, then the target is denied, that is
<script type="math/tex">|00\rangle \rightarrow{} |00\rangle, |01\rangle \rightarrow{} |01\rangle, |10\rangle \rightarrow{} |11\rangle, |11\rangle \rightarrow{} |10\rangle</script>
Equivalently, <code class="highlighter-rouge">CNOT</code> can be seen as the transformation
<script type="math/tex">|A,B\rangle \mapsto |A,B\rangle \otimes A</script>
where
<script type="math/tex">A</script>
is the control qubit,
<script type="math/tex">B</script>
is the target and
<script type="math/tex">\otimes</script>
is the sum module
<script type="math/tex">2</script>
that is the classical <code class="highlighter-rouge">XOR</code> operation. The representation as a unitary matrix is:
<script type="math/tex">% <![CDATA[
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0
\end{bmatrix} %]]></script>
where the first column describes the transformation of the vector of the computational base
<script type="math/tex">|00\rangle</script>, the second that of the vector
<script type="math/tex">|01\rangle</script>, the third of
<script type="math/tex">|10\rangle</script>
and the fourth of
<script type="math/tex">|11\rangle</script>.</p>

<p>It is important to note that the <code class="highlighter-rouge">CNOT</code>, like all unit transformations, is invertible: input can always be obtained from the output. This is not true for the <code class="highlighter-rouge">XOR</code> and <code class="highlighter-rouge">NAND</code> logic gates: in general, classic operations are irreversible. The <code class="highlighter-rouge">CNOT</code> gate and one-qubit ports represent the prototypes of all quantum logic gates. In fact, is is possible to demonstrate the universality of these operations (later on
this).</p>

<h3 id="ibm-q---testing-the-cnot-gate">IBM Q - Testing the <code class="highlighter-rouge">CNOT</code> gate</h3>

<p><strong>[from Matteo: Add experiment over this.]</strong></p>

<p>The gates made with vertical lines connecting two qubits together are a physical implementation of the <code class="highlighter-rouge">CNOT</code> gates just introduced. These two-qubit gates function like an exclusive <code class="highlighter-rouge">OR</code> gate in conventional digital logic. The qubit at the solid-dot end of the <code class="highlighter-rouge">CNOT</code> gate
controls the whether or not the target qubit at the
<script type="math/tex">\oplus</script>-end of the gate is inverted (hence <code class="highlighter-rouge">controlled NOT</code>, or <code class="highlighter-rouge">CNOT</code>). Some gates, like the <code class="highlighter-rouge">CNOT</code>, have hardware constraints; the set of allowed connections is defined by the schematic of the device located below the quantum Composer, along with recently calibrated device parameters.</p>

<p>### Quantum circuits</p>

<h4 id="swap-operation">SWAP operation</h4>
<p>A simple example of a quantum circuit is given in Fig. <a href="#circuit">[circuit]</a>{reference-type=”ref” reference=”circuit”}.</p>

<p align="center"><img src="http://image.ibb.co/gP4piH/circuit.png" alt="perceptron" style="width: 40%; marker-top: -10px;" /></p>

<p>The circuit realizes the exchange of two qubits states. Given in input the register of two qubits
<script type="math/tex">|a, b\rangle</script>, a <code class="highlighter-rouge">CNOT</code> is carried out with qubit of control a. As a result,
<script type="math/tex">b</script>
is replaced by
<script type="math/tex">a \otimes b</script>. The latter is taken as a control of a second <code class="highlighter-rouge">CNOT</code> with target
<script type="math/tex">a</script>. The effect is that a is replaced by
<script type="math/tex">a \otimes (a \otimes b) = b</script>. Finally, a last <code class="highlighter-rouge">CNOT</code> with control
<script type="math/tex">b</script>
and target
<script type="math/tex">a \otimes b</script>
realizes the exchange by replacing
<script type="math/tex">a \otimes b</script>
with
<script type="math/tex">a</script>.
The line with the black dot indicates the control qubit, while the qubits target are the
<script type="math/tex">n</script>
inputs of
<script type="math/tex">U</script>. According to this convention the controlled-<code class="highlighter-rouge">NOT</code> is nothing more than a controlled-<script type="math/tex">U</script>
with
<script type="math/tex">U = X</script>.</p>

<p align="center"><img src="http://image.ibb.co/eLkUiH/mesured.png" alt="perceptron" style="width: 40%; marker-top: -10px;" /></p>

<p>Testing the swapping of the qubit is really simple. Let’s prepare a simulated register with two qubit in the initial state
<script type="math/tex">|10\rangle</script>, like the one shown in</p>

<p align="center"><img src="https://github.com/made2591/quantum-notes/blob/master/images/quantumSwap.png?raw=true" style="marker-top: -10px;" /></p>

<p><strong>NOTE</strong>: in <em>IBM</em> platform the histogram will provide the result in the opposite order. For instance, in the figure, the unique bar on histogram is labelled
<script type="math/tex">10</script>, where
<script type="math/tex">1</script>
refer to the second (<code class="highlighter-rouge">q[1]</code>) qubit in the register and
<script type="math/tex">0</script>
to the first (<code class="highlighter-rouge">q[0]</code>). Thus, as show in the histogram, the result will be the swapping between the two qubit. Mathematically, the proof is simple. Let’s start by saying that
<script type="math/tex">|0\rangle = \binom{1}{0}</script>
Thus,
<script type="math/tex">% <![CDATA[
X|0\rangle = \binom{1}{0}\left({\begin{matrix} 0 & 1 \\ 1 & 0 \\ \end{matrix}}\right) %]]></script></p>

<p>The initial state is ready (with value
<script type="math/tex">|10\rangle</script>). Then, we apply a <code class="highlighter-rouge">CNOT</code>. Our first qubit is in
<script type="math/tex">|1\rangle</script>, thus the second qubit will be negated as well: the status become
<script type="math/tex">|11\rangle</script>. Then, a second <code class="highlighter-rouge">CNOT</code> is applied using the second qubit as a control and the first as a target qubit. The first qubit change to the
<script type="math/tex">|0\rangle</script>, bringing the entire register in the
<script type="math/tex">|01\rangle</script>. The last <code class="highlighter-rouge">CNOT</code> doesn’t anything: the swap is completed. Ok but what if the initial status was set tup
<script type="math/tex">|00\rangle</script>
or any other possible permutation? Let’s see the effect of the circuit over the four possible initial state (the third is the one we already described).</p>

<script type="math/tex; mode=display">|00\rangle \xrightarrow{1 \; CNOT} |00\rangle \xrightarrow{2 \; CNOT} |00\rangle \xrightarrow{3 \; CNOT} |00\rangle</script>

<script type="math/tex; mode=display">|01\rangle \xrightarrow{1 \; CNOT} |01\rangle \xrightarrow{2 \; CNOT} |11\rangle \xrightarrow{3 \; CNOT} |10\rangle</script>

<script type="math/tex; mode=display">|10\rangle \xrightarrow{1 \; CNOT} |11\rangle \xrightarrow{2 \; CNOT} |01\rangle \xrightarrow{3 \; CNOT} |01\rangle</script>

<script type="math/tex; mode=display">|11\rangle \xrightarrow{1 \; CNOT} |10\rangle \xrightarrow{2 \; CNOT} |10\rangle \xrightarrow{3 \; CNOT} |11\rangle</script>

<h3 id="quantum-teleportation">Quantum teleportation</h3>

<p>Continue <a href="https://github.com/made2591/quantum-notes">here</a>…</p>

<p>Thank you everybody for reading!</p>

<div class="footnotes">
  <ol>
    <li id="fn:susskind2014quantum">
      <p>Available on <a href="https://www.amazon.com/QUANTUM-MECHANICS-THEORETICAL-Hardcover-Feb-25-2014/dp/B00UMYPVE4">Amazon</a>&nbsp;<a href="#fnref:susskind2014quantum" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>


<div class="comments">
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'made2591';

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

</div>

<hr/>


  
    <div class="post-navs row">
      
        <div class="col-md-6 post-nav">

          <h3 class="section-header">
            Older
            <span class="text-muted"> &middot; </span>
            <a href="/archive">View Archive (35)</a>
          </h3>

          <h2 class="post-title-link"><a href="/posts/aws-lambda">AWS Lambda, GoLang and Grafana to perform sentiment analysis for your company / business</a></h2>
          <h3 id="introduction">Introduction</h3>
<p>In this article I will talk about my experience with AWS Lambda + API Gateway, GoLang (of course) and Grafana to build a sentiment analysis tool over customizable topics. Who should you read this post? Don’t know, maybe a CIO, a CTO, a CEO, a generic Chief or a MasterChef, for sure an AWS and GoLang fan like me. First of all: to better understand how to use Elasticsearch, read my previous post <a href="https://made2591.github.io/posts/elasticnas">Elasticsearch over My home Network Attached Storage</a>: it’s not so exciting as it seems, but you will have a general idea about what is Elasticsearch and how can you use it. Second: if you don’t know about AWS Lambda, study it. I personally believe that it represents one of the most interesting services currently offered by AWS: as they state, <em>AWS Lambda lets you run code without provisioning or managing servers</em>. You pay only for the compute time you consume and there is no charge when your code is not running. The amazing thing is that with a Free Tier trial you have 1 milions requests for free - O.O - to run code of any type of application or backend service - all with zero administration: you just upload your code - unfortunately the online editor for GoLang is not supported yet - and AWS Lambda<sup id="fnref:lambda"><a href="#fn:lambda" class="footnote">1</a></sup> takes care of everything required to run and scale your code with high availability. You can even set up your code to automatically trigger from other AWS services - as I have done with API Gateway - or call it directly from any web or mobile app. And…last but definetly not the least, why I’m writing this post!? Because starting from <a href="https://aws.amazon.com/it/blogs/compute/announcing-go-support-for-aws-lambda/">15 January 2018</a>, AWS Lambda support GoLang!!!</p>

<div class="footnotes">
  <ol>
    <li id="fn:lambda">
      <p>You can find more information <a href="https://aws.amazon.com/lambda/?nc1=h_ls">here</a>&nbsp;<a href="#fnref:lambda" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

        </div>
      
      

        <div class="col-md-6 post-nav">
          <h3 class="section-header">
            Newer
            
          </h3>

          <h2 class="post-title-link"><a href="/posts/aws-step-functions">Node.js, DynamoDB, and AWS Step Functions to collect <em>sentimented</em> movie reviews</a></h2>
          <h3 id="introduction">Introduction</h3>
<p>Recently I worked with AWS Lambda and API Gateway to extend my set of personal APIs and collect information from several sources. I wrote an article on that (if you want to <a href="https://made2591.github.io/posts/aws-lambda">have a look</a>). In this article I will talk about the AWS Step Functions service that enable create finite states machines to easy coordinate the components of distributed applications and microservices using visual workflows. Why AWS Step Functions? Because they let me create a tool to gather movie titles in teather, search for reviews about each of them and make a basic sentiment analysis over the review to help me decide what’s worth watching at teather and what’s worth waiting for on Netflix :D
More in general, with AWS Step Functions, you can build applications made of individual components that each perform a discrete function: this lets you scale and change applications quickly. Step Functions is a reliable way to coordinate components and step through the functions of your application. They provides a graphical console to arrange and visualize the components of your application as a series of steps. This makes it simple to build and run multistep applications. Step Functions automatically triggers and tracks each step, and retries when there are errors, so your application executes in order and as expected. Step Functions logs the state of each step, so when things do go wrong, you can diagnose and debug problems quickly.</p>


        </div>
      
    </div>
  



          <div id="footer">
<hr/>
  <div class="pull-left">
    &copy;2019.
    Built with <a href="http://jekyllrb.com/">Jekyll</a> and
    <a href="https://github.com/kirqe/autm-rb">Autm-rb</a>. Thanks to <a href="https://github.com/kirqe">kirqe</a>.
  </div>

  <div class="pull-right">
    <span class="credits pull-right social">
      
        
          <a href="https://github.com/made2591/" target="_blank"><i class="fa fa-github"></i></a>
        
      
        
          <a href="https://twitter.com/made2591" target="_blank"><i class="fa fa-twitter"></i></a>
        
      
        
          <a href="https://linkedin.com/in/mmadeddu" target="_blank"><i class="fa fa-linkedin"></i></a>
        
      
        
          <a href="https://www.facebook.com/matteo.madeddu" target="_blank"><i class="fa fa-facebook"></i></a>
        
      
    </span>
  </div>
</div>

        </section>
    </div>
    </div>
    <script src="/public/javascripts/jquery.min.js"></script>
    <script src="/public/javascripts/bootstrap.min.js"></script>
    <!-- Place your <script> tags here. -->

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<script id="dsq-count-scr" src="//made2591-github-io.disqus.com/count.js" async></script>

<!-- disqus comment counter -->
<script type="text/javascript">
	/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'made2591-github-io';

	/* * * DON'T EDIT BELOW THIS LINE * * */
	(function () {
	    var s = document.createElement('script'); s.async = true;
	    s.type = 'text/javascript';
	    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
	    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
	}());
</script>
<!-- /disqus comment counter -->

<!-- google analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111283556-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-111283556-1');
</script>
<!-- /google analytics -->

  </body>
</html>
