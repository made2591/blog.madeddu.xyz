<!DOCTYPE html>
<html>
  <head>
    <!-- Google Tag Manager -->
    <!--<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-M8WBXH7');</script>-->
    <!-- End Google Tag Manager -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href=/public/stylesheets/bs.css?random=@Environment.TickCount>
    <link rel="stylesheet" href=/public/stylesheets/styles.css?random=@Environment.TickCount>
    <link rel="stylesheet" href=/public/stylesheets/pygment_trac.css?random=@Environment.TickCount>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css">
    <link rel="canonical" href="made2591.github.io/posts/go-py-benchmark">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
      <link rel="icon" type="image/x-icon"  href="/favicon.ico" />
    <title>GoLang vs Python: deep dive into the concurrency | Matteo Madeddu</title>
    <!--[if lt IE 9]>

      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  </head>
  <body>
    <!-- Google Tag Manager (noscript) -->
    <!--<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M8WBXH7"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div class="wrapper">
        <section>
          <div id="header">
  <h1>
    <a id="sitename" href="">Matteo Madeddu</a>
  </h1>

  <!-- Add something about you in p tag-->
  <p>Mac OS lover, Docker fan, Go explorer, Python geek, Trello addicted.</p>
  <hr/>

  <span class="credits pull-left">
    
      <a href="/">Home</a>  | 
    
      <a href="/blog">Blog</a>  | 
    
      <a href="/archive">Archive</a>  | 
    
      <a href="/about">About</a>  | 
    
      <a href="/matteo_madeddu_cv.pdf">Resume</a>  | 
    
      <a href="/quotes">Quotes</a> 
    
  </span>

  <span class="credits pull-right social">
    
      
        <a href="https://github.com/made2591/" target="_blank"><i class="fa fa-github"></i></a>
      
    
      
        <a href="https://twitter.com/made2591" target="_blank"><i class="fa fa-twitter"></i></a>
      
    
      
        <a href="https://linkedin.com/in/mmadeddu" target="_blank"><i class="fa fa-linkedin"></i></a>
      
    
      
        <a href="https://www.facebook.com/matteo.madeddu" target="_blank"><i class="fa fa-facebook"></i></a>
      
    
  </span>


</div>


          <div class="post-title">
    <h1>GoLang vs Python: deep dive into the concurrency</h1>
    <p class="text-muted">
    


    17 Jan 2018
    
     | <i class="fa fa-comment"></i> <a class="text-muted" href="/posts/go-py-benchmark/#disqus_thread"></a>
    

    
      | <i class="fa fa-tag"></i>
      
        <a class="text-muted" href="/tags/#coding ">coding</a>,
      
        <a class="text-muted" href="/tags/#golang ">golang</a>,
      
        <a class="text-muted" href="/tags/#python ">python</a>,
      
        <a class="text-muted" href="/tags/#goroutine ">goroutine</a>,
      
        <a class="text-muted" href="/tags/#algorithms ">algorithms</a>,
      
        <a class="text-muted" href="/tags/#benchmark ">benchmark</a>
      
    
  </p>
</div>

  <h3 id="introduction">Introduction</h3>
<p>In the last months, I worked a lot with GoLang on several projects. Although I’m certainly not an expert, there are several things that I really appreciate about this language: first, it has a clear and simple syntax, and more than once I noticed that the style of the Github developers is very close to the style used in old C programs. From a theoretical point of view, GoLang seems to take the best of all worlds: there is the power of high-level languages, made simple by clear rules - even if sometime they are a little bit binding - that can impose a solid logic to the code. There is the simplicity of the imperative style, made of primitive types with the size in bits in their name, but without the boredom of manipulating strings as array of characters. However, two really useful and interesting features in my opinion are the goroutine and the channels.</p>

<p align="center"><img src="https://ksr-ugc.imgix.net/assets/013/579/935/cd53c61559974d1fa22a094ecff1f8a3_original.jpg?crop=faces&amp;w=1552&amp;h=873&amp;fit=crop&amp;v=1472824649&amp;auto=format&amp;q=92&amp;s=e7e49d2e6d5bcf4ef3a486facef11cc3" style="width: 100%; marker-top: -10px;" /></p>

<h3 id="preamble">Preamble</h3>
<p>To understand why GoLang handles concurrency better, you first need to know what concurrency exactly<sup id="fnref:talk"><a href="#fn:talk" class="footnote">1</a></sup> is. Concurrency is the composition of independently executing computations: better, is a way to write clean code that interacts well with the real world. Often people confuse the concept of concurrency with the concept of parallelism, even if concurrency <script type="math/tex">\neq</script> parallelism: yes, although it <em>enables</em> parallelism. So, if you have only one processor, your program can still be concurrent but it cannot be parallel. On the other hand, a well-written concurrent program might run efficiently in parallel on a multiprocessor<sup id="fnref:rob"><a href="#fn:rob" class="footnote">2</a></sup>. That property could be important.
Let’s talk about how GoLang let your program takes advantage of running in a multiprocessor/multithreaded environment, or, <em>what tools GoLang provides to write concurrent program</em> because it’s not about thread or core: it’s all about routine.</p>

<h4 id="goroutine">Goroutine</h4>
<p>Suppose we have a function call <code class="highlighter-rouge">f(s)</code>: this is how we would call that in the usual way, running it <em>synchronously</em>. To invoke this function in a <code class="highlighter-rouge">goroutine</code>, use <code class="highlighter-rouge">go f(s)</code>. This new goroutine will execute <em>concurrently</em> with the calling one. But… what is a goroutine? It’s an independently executing function, launched by a <code class="highlighter-rouge">go</code> statement. It has its own call stack, which grows and shrinks as required and it’s very cheap. It’s practical to have thousands, even hundreds of thousands of goroutines, but it’s not a thread. In fact, there might be only one thread in a program with thousands of goroutines. Instead, <em>goroutines are multiplexed dynamically onto threads as needed to keep all the goroutines running</em>. If you think of it as a very cheap thread, you won’t be far off.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">f</span><span class="p">(</span><span class="n">from</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="m">3</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="x"> </span><span class="s">":"</span><span class="p">,</span><span class="x"> </span><span class="n">i</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">

    </span><span class="c">// Suppose we have a function call `f(s)`. Here's how</span><span class="x">
    </span><span class="c">// we'd call that in the usual way, running it</span><span class="x">
    </span><span class="c">// synchronously.</span><span class="x">
    </span><span class="n">f</span><span class="p">(</span><span class="s">"direct"</span><span class="p">)</span><span class="x">

    </span><span class="c">// To invoke this function in a goroutine, use</span><span class="x">
    </span><span class="c">// `go f(s)`. This new goroutine will execute</span><span class="x">
    </span><span class="c">// concurrently with the calling one.</span><span class="x">
    </span><span class="k">go</span><span class="x"> </span><span class="n">f</span><span class="p">(</span><span class="s">"goroutine"</span><span class="p">)</span><span class="x">

    </span><span class="c">// You can also start a goroutine for an anonymous</span><span class="x">
    </span><span class="c">// function call.</span><span class="x">
    </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">msg</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="x">
    </span><span class="p">}(</span><span class="s">"going"</span><span class="p">)</span><span class="x">

    </span><span class="c">// Our two function calls are running asynchronously in</span><span class="x">
    </span><span class="c">// separate goroutines now, so execution falls through</span><span class="x">
    </span><span class="c">// to here. This `Scanln` code requires we press a key</span><span class="x">
    </span><span class="c">// before the program exits.</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">input</span><span class="x"> </span><span class="kt">string</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Scanln</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"done"</span><span class="p">)</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<h5 id="more-in-details">More in details<sup id="fnref:docr"><a href="#fn:docr" class="footnote">3</a></sup></h5>
<p>As I said, the idea behind the coroutine is to multiplex <strong>independently executing functions</strong> — coroutines — onto a set of threads. When a coroutine blocks, such as by calling a blocking system call, the <strong>run-time automatically moves other coroutines on the same operating system thread to a different, runnable thread</strong> so they won’t be blocked. These coroutine are called <strong>goroutines</strong> and are very cheap: they have little overhead beyond the memory for the stack, which is just a few kilobytes. Further, to make the stacks small, Go’s run-time uses resizable, bounded stacks. A newly minted goroutine is given a few kilobytes, which is almost always enough. When it isn’t, the run-time grows (and shrinks) the memory for storing the stack automatically, allowing many goroutines to live in a modest amount of memory. The CPU overhead averages about three cheap instructions per function call, and that the reason why it’s so practical to create hundreds of thousands of goroutines in the same address space. If goroutines were just threads, system resources would run out at a much smaller number.</p>

<p>Ok, really cool but…why!?!? Why do we write concurrent program?! To do our jobs faster (even if writing correct concurrent program could take you more time than the amount of time you would gain running your task in a parallel environment XD). A tipical threaded situation includes a main thread that allocates some shared memory and stores its location in <code class="highlighter-rouge">p</code>; than main thread starts <script type="math/tex">n</script> worker threads, passing the pointer <code class="highlighter-rouge">p</code> to them and the workers can use <code class="highlighter-rouge">p</code> and work on the data pointed to by <code class="highlighter-rouge">p</code>. But what if threads start updating the same memory address - I mean, this is one of the hardest point of computer science. Ok, let’s keep it simple: from <em>the-operating-system-point-of-view</em>, some atomic system calls let you lock the access to a <code class="highlighter-rouge">shared memory</code> zone (I’m talking about semaphores, messages queues, locks, etc). From the <em>language-poin-of-view</em>, there are normally a set of primitive that - in the end - call the required system calls and let you sync the access to a shared memory zone (I’m talking about packages like multiprocessing, multithreading, pools, etc). Let’s talk about a tool of GoLang that help you deal with concurrency comunication between goroutine: the channels.</p>

<h4 id="channels">Channels</h4>
<p>Channels are a typed conduit through which you can send and receive values with the channel operator <code class="highlighter-rouge">&lt;-</code>. And that’s all :D You only need to know that when a <em>main</em> function executes <code class="highlighter-rouge">&lt;–c</code>, it will wait for a value to be sent. Similarly, when the <em>goroutined</em> function executes <code class="highlighter-rouge">c &lt;– value</code>, it waits for a receiver to be ready. A sender and receiver must both be ready to play their part in the communication. Otherwise we wait until they are: you don’t have to deal with semaphores, locks, etc: channels <strong>both communicate and synchronize</strong>. This is really important to remember and understand, and also one of the biggest difference between GoLang and other languages I know.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">sum</span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">c</span><span class="x"> </span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">sum</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">v</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">s</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">sum</span><span class="x"> </span><span class="o">+=</span><span class="x"> </span><span class="n">v</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="n">c</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="n">sum</span><span class="x"> </span><span class="c">// send sum to c</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">s</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">7</span><span class="p">,</span><span class="x"> </span><span class="m">2</span><span class="p">,</span><span class="x"> </span><span class="m">8</span><span class="p">,</span><span class="x"> </span><span class="o">-</span><span class="m">9</span><span class="p">,</span><span class="x"> </span><span class="m">4</span><span class="p">,</span><span class="x"> </span><span class="m">0</span><span class="p">}</span><span class="x">

	</span><span class="n">c</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x">
	</span><span class="k">go</span><span class="x"> </span><span class="n">sum</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">/</span><span class="m">2</span><span class="p">],</span><span class="x"> </span><span class="n">c</span><span class="p">)</span><span class="x">
	</span><span class="k">go</span><span class="x"> </span><span class="n">sum</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">/</span><span class="m">2</span><span class="o">:</span><span class="p">],</span><span class="x"> </span><span class="n">c</span><span class="p">)</span><span class="x">
	</span><span class="n">x</span><span class="p">,</span><span class="x"> </span><span class="n">y</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">c</span><span class="p">,</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">c</span><span class="x"> </span><span class="c">// receive from c</span><span class="x">

	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="x"> </span><span class="n">y</span><span class="p">,</span><span class="x"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<h5 id="more-in-details-1">More in details<sup id="fnref:docc"><a href="#fn:docc" class="footnote">4</a></sup></h5>
<p>As official documentation states, a channel <em>provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type</em>. It’s - quite - simple. What I didn’t say yet, is that a channel as a type, different from the type of messages it admits:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ChannelType = ( "chan" | "chan" "&lt;-" | "&lt;-" "chan" ) ElementType
</code></pre></div></div>

<p>The optional <code class="highlighter-rouge">&lt;-</code> operator specifies the channel direction, send or receive. If no direction is given, the channel is bidirectional. A channel may be constrained only to send or only to receive by conversion or assignment.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="x">    
    </span><span class="k">chan</span><span class="x"> </span><span class="n">T</span><span class="x">          </span><span class="c">// can be used to send and receive values of type T</span><span class="x">
    </span><span class="k">chan</span><span class="o">&lt;-</span><span class="x"> </span><span class="kt">float64</span><span class="x">  </span><span class="c">// can only be used to send float64s</span><span class="x">
    </span><span class="o">&lt;-</span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="x">      </span><span class="c">// can only be used to receive ints</span></code></pre></figure>

<p>To help you in solving some particular sync problems, you can also create a <code class="highlighter-rouge">buffered channel</code>, using the function make (<code class="highlighter-rouge">make(chan int, 100)</code>). The capacity, in number of elements, sets the size of the buffer in the channel. If the capacity is zero or absent, the channel is unbuffered and communication succeeds only when both a sender and receiver are ready. Otherwise, the channel is buffered and communication succeeds without blocking if the buffer is not full (sends) or not empty (receives). A nil channel is never ready for communication: I found out that by using a buffered channel you can implicit set the maximum number of go routine to have at runtime and this will be really usefull for my benchmark.</p>

<h4 id="summary">Summary</h4>
<p>To summarize, you can call a function - even anonymous - in a goroutine. Then put the result in a channel and, by default, sends and receives block until the other side is ready. All these features <em>allows goroutines to synchronize without explicit locks or condition variables</em>. Ok but… how do they perform?</p>

<h3 id="golang-vs-python">GoLang vs Python</h3>
<p>Ok, I’m a Python lover - I guess, because it’s in the title and I don’t remember where the .md respective source is - so I decided to make a comparision to see how these magical GoLang tricky statements really perform. To do that, I wrote a simple go-py program (<a href="https://github.com/made2591/go-py-benchmark">here</a> the code) that completes the merge sort over a list of random integers and can be run in a single-core environment or multicore environment. Or, in a single-_routine_ or multi-_routine_ environment: this is because, as I said, go-routine is a - unavailable in Python - concept that goes more in depth than thread - remember that more than one go-routine could belong to one single thread. Instead, from a Python point of you, you only can work with process, threads and also semaphores, locks, rlocks and so on but it’s impossible to reproduce exactly the same computation - I mean, this is normal, they are different languages but both of them in the end call a set of system calls. In any case, I think that what you can do when you are running this kind of concurrency experiments is to reproduce a computation <em>as much as possible</em> logically equivalent. Let’s start from the GoLang version.</p>

<h4 id="golang-merge-sort">GoLang Merge Sort</h4>
<p>Both GoLang and Python version of program provide two function:</p>
<ul>
  <li>Single <em>routine</em>;</li>
  <li>Multiple <em>prefixed number of routine</em>;</li>
</ul>

<h5 id="simple-go-version">Simple Go Version</h5>
<p>Ok, I will not talk too much about single routine methods: it’s really simple. Below you can see the code of the most optimized version I was able to think about (in terms of io operations, etc) - the commented version on <a href="https://github.com/made2591/go-py-benchmark/blob/master/main.go">Github</a>:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span><span class="x"> </span><span class="n">msort_sort</span><span class="p">(</span><span class="n">a</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="m">1</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="n">a</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="n">m</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="kt">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Floor</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span><span class="x"> </span><span class="o">/</span><span class="x"> </span><span class="m">2</span><span class="p">))</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">msort_merge</span><span class="p">(</span><span class="n">msort_sort</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="n">m</span><span class="p">]),</span><span class="x"> </span><span class="n">msort_sort</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="o">:</span><span class="p">]))</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">msort_merge</span><span class="p">(</span><span class="n">l</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">r</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">a</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="o">||</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">if</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">a</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="x"> </span><span class="n">r</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">])</span><span class="x">
            </span><span class="k">if</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="m">1</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">r</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">r</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="x">
            </span><span class="p">}</span><span class="x"> </span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">r</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span><span class="x">
            </span><span class="p">}</span><span class="x">
        </span><span class="p">}</span><span class="x"> </span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">if</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="o">||</span><span class="x"> </span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="n">r</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">])</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">a</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="x"> </span><span class="n">l</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">])</span><span class="x">
                </span><span class="k">if</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="m">1</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">l</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">l</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="x">
                </span><span class="p">}</span><span class="x"> </span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">l</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span><span class="x">
                </span><span class="p">}</span><span class="x">
            </span><span class="p">}</span><span class="x"> </span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="k">if</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="n">a</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="x"> </span><span class="n">r</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">])</span><span class="x">
                    </span><span class="k">if</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="m">1</span><span class="x"> </span><span class="p">{</span><span class="x">
                        </span><span class="n">r</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">r</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="x">
                    </span><span class="p">}</span><span class="x"> </span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
                        </span><span class="n">r</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span><span class="x">
                    </span><span class="p">}</span><span class="x">
                </span><span class="p">}</span><span class="x">
            </span><span class="p">}</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">reverse</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<p>I don’t think it needs explanation: if you have any questions, don’t hesitate write me in the comments! I will answer as soon as possible.</p>

<h5 id="concurrent-go-version">Concurrent Go Version</h5>
<p>Let’s talk about the <strong>concurrent version</strong>. We could split the array and call go sub routine from the main routine, but how can we control the maximum number of concurrent go-routine - or workers - to run? Well, one way<sup id="fnref:s1"><a href="#fn:s1" class="footnote">5</a></sup> to limit concurrency in Go is by using a buffered channel (semaphore). As I said, when you create a channel with a fixed dimension - or buffered - communication succeeds without blocking if the buffer is not full (sends) or not empty (receives), so you can implements a <em>semaphore</em> to easily block execution based on the number of concurrent units of actions you want to have. Really cool but… there is a problem: a channel is a channel, and even if buffered, basic sends and receives on channels are <code class="highlighter-rouge">blocking</code>. 
Fortunately, GoLang is simply awesome and let you create <strong>explicit non-blocking channels</strong>, using the <code class="highlighter-rouge">select</code> statement<sup id="fnref:nbcs"><a href="#fn:nbcs" class="footnote">6</a></sup>: thus, you can use the select with default clause to implement non-blocking sends, receives, and even non-blocking multi-way selects. There are some others few statement to explain, after my <em>prefixed-maximum-number-of-concurrent-goroutine</em> version of merge sort:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// Returns the result of a merge sort - the sort part - over the passed list</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="n">merge_sort_multi</span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">sem</span><span class="x"> </span><span class="k">chan</span><span class="x"> </span><span class="k">struct</span><span class="p">{})</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">

    </span><span class="c">// return ordered 1 element array</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="x"> </span><span class="o">&lt;=</span><span class="x"> </span><span class="m">1</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="n">s</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// split length</span><span class="x">
    </span><span class="n">n</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="x"> </span><span class="o">/</span><span class="x"> </span><span class="m">2</span><span class="x">

    </span><span class="c">// create a wait group to wait for both goroutine call before final merge step</span><span class="x">
    </span><span class="n">wg</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">{}</span><span class="x">
    </span><span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">2</span><span class="p">)</span><span class="x">

    </span><span class="c">// result of goroutine</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">l</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">r</span><span class="x"> </span><span class="p">[]</span><span class="kt">int</span><span class="x">

    </span><span class="c">// check if passed buffered channel is full</span><span class="x">
    </span><span class="k">select</span><span class="x"> </span><span class="p">{</span><span class="x">

    </span><span class="c">// check if you can acquire a slot</span><span class="x">
    </span><span class="k">case</span><span class="x"> </span><span class="n">sem</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="k">struct</span><span class="p">{}{}</span><span class="o">:</span><span class="x">

        </span><span class="c">// call another goroutine worker over the first half</span><span class="x">
        </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">l</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">merge_sort_multi</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">:</span><span class="n">n</span><span class="p">],</span><span class="x"> </span><span class="n">sem</span><span class="p">)</span><span class="x">

            </span><span class="c">// free a slot</span><span class="x">
            </span><span class="o">&lt;-</span><span class="n">sem</span><span class="x">

            </span><span class="c">// unlock one semaphore</span><span class="x">
            </span><span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span><span class="x">
        </span><span class="p">}()</span><span class="x">
    </span><span class="k">default</span><span class="o">:</span><span class="x">
        </span><span class="n">l</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">msort_sort</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">:</span><span class="n">n</span><span class="p">])</span><span class="x">
        </span><span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// the same over the second half</span><span class="x">
    </span><span class="k">select</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">case</span><span class="x"> </span><span class="n">sem</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="k">struct</span><span class="p">{}{}</span><span class="o">:</span><span class="x">
            </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
                </span><span class="n">r</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">merge_sort_multi</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="o">:</span><span class="p">],</span><span class="x"> </span><span class="n">sem</span><span class="p">)</span><span class="x">
                </span><span class="o">&lt;-</span><span class="n">sem</span><span class="x">
                </span><span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span><span class="x">
            </span><span class="p">}()</span><span class="x">
        </span><span class="k">default</span><span class="o">:</span><span class="x">
            </span><span class="n">r</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">msort_sort</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="o">:</span><span class="p">])</span><span class="x">
            </span><span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// wait for go subroutine</span><span class="x">
    </span><span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span><span class="x">

    </span><span class="c">// return</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">msort_merge</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="x"> </span><span class="n">r</span><span class="p">)</span><span class="x">

</span><span class="p">}</span></code></pre></figure>

<p>As you can see, in my default select action, I wrote a call to the single-routined version of merge sort. However, there is another interesting tool in the code: it is the <code class="highlighter-rouge">WaitGroup</code> object provided by the sync package. From the official documentations<sup id="fnref:wg"><a href="#fn:wg" class="footnote">7</a></sup>, a WaitGroup waits for a collection of goroutines to finish. The main goroutine calls <code class="highlighter-rouge">Add</code> to set the number of goroutines to wait for. Then each of the goroutines runs and calls <code class="highlighter-rouge">Done</code> when finished. At the same time, <code class="highlighter-rouge">Wait</code> can be used to block until all goroutines have finished.</p>

<h4 id="python-merge-sort">Python Merge Sort</h4>
<p>Ok, at this point, if you arrived here, I will be honest: I’m not a concurrency expert, actually I really hate concurrency, but writing this post and benchmarking GoLang channel learnt me a lot about this theme: the part of reproducing a computation <em>as much as possible</em> logically equivalent in Python was really - I mean, REALLY - difficult.</p>

<h5 id="simple-py-version">Simple Py Version</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">msort_sort</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">msort_merge</span><span class="p">(</span><span class="n">msort_sort</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">msort_sort</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">msort_merge</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">args</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">left</span> <span class="ow">or</span> <span class="n">right</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">right</span> <span class="ow">or</span> <span class="n">left</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
    <span class="n">a</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">a</span></code></pre></figure>

<h5 id="concurrent-py-version">Concurrent Py Version</h5>
<p>I had to think a lot about a concurrent version: first, I thought to use an array of Threads / Processes (later on this topic) and start / joining them but then… I realized this wouldn’t be so much equal to my concurrent GoLang version. First, because the call to more then one thread / process would be done <em>only once</em> over a partition of original data - to be merged in the end, eventually in a <em>concurrent way</em>: this is not exactly the behavior of my GoLang version, that call recursively a concurrent routine until the semaphore accept new concurrent routines - and in the end call a single-routined instance of the sorting method. So I thought “I simply can’t realize a multi-routined (threads or processes) of my merge sort in Python using a simple <em>one-shot</em> split method, because it is not <em>computationally</em> equivalent”. For this reason, the first thing I tried was to replice exactly the same behavior of <em>Channel</em> and <em>WaitGroup</em> using the semaphores primitive in Python - and after some days of work I got it. Let’s have a look at the code:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">merge_sort_parallel_golike</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">bufferedChannel</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>

    <span class="c"># if array length is 1, is ordered : return</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span>

    <span class="c"># compute length</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c"># append thread for subroutine</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># try to acquire channel</span>
    <span class="k">if</span> <span class="n">bufferedChannel</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

        <span class="c"># if yes, setup call on the first half</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">merge_sort_parallel_golike</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">array</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">bufferedChannel</span><span class="p">,</span> <span class="n">results</span><span class="p">,)))</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="c"># else call directly the merge sort over the first halft</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msort_sort</span><span class="p">(</span><span class="n">array</span><span class="p">[:</span><span class="n">n</span><span class="p">]))</span>

    <span class="c"># the same, in the second half</span>
    <span class="k">if</span> <span class="n">bufferedChannel</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

        <span class="n">ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">merge_sort_parallel_golike</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">n</span><span class="p">:],</span> <span class="n">bufferedChannel</span><span class="p">,</span> <span class="n">results</span><span class="p">,)))</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msort_sort</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">n</span><span class="p">:]))</span>

    <span class="c"># start thread</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="c"># wait for finish</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="c"># append results</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msort_merge</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>

    <span class="c"># unlock the semaphore for another threads for next call to merge_sort_parallel_golike</span>
    <span class="c"># try is to prevent arise of exception in the end</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">bufferedChannel</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    
    <span class="c"># manager to handle routine response</span>
    <span class="n">manager</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">()</span> 
    <span class="n">responses</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="nb">list</span><span class="p">()</span>
    
    <span class="n">sem</span> <span class="o">=</span> <span class="n">BoundedSemaphore</span><span class="p">(</span><span class="n">routinesNumber</span><span class="p">)</span>
    <span class="n">merge_sort_parallel_golike</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sem</span><span class="p">,</span> <span class="n">responses</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">responses</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></code></pre></figure>

<p>Ok, let’s start from manager. The <code class="highlighter-rouge">Manager</code> object initialized in the main provides a struct to put responses of call - more or less similar to a <code class="highlighter-rouge">Queue</code>. The <code class="highlighter-rouge">BoundedSemaphore</code> plays the role of the bounded channel semaphore I talked before. A semaphore is a lock mechanism more advanced that simple lock: it has an internal counter rather than a lock flag, and it only blocks if more than a given number of threads have attempted to hold the semaphore. Depending on how the semaphore is initialized, this allows multiple threads to access the same code section simultaneously: fortunately, you can <em>try</em> to acquire lock and go ahead in execution if you fail - this plays the <code class="highlighter-rouge">select</code> trick I mentioned before used in the GoLang version - by using the <code class="highlighter-rouge">blocking=False</code> parameter (<code class="highlighter-rouge">bufferedChannel.acquire(blocking=False)</code>). With <code class="highlighter-rouge">join</code> I emulated the behavior of the <code class="highlighter-rouge">WaitGroup</code>, because I thought it was the standard way to sync the two threads and wait for their end before proceeding with the final merge step. Any questions?</p>

<p>You are wondering <em>“How does this perform?!”</em> Ok, it SUCKS. I mean: a lot. So I try to search for something more efficient… and I found this - similar to the first solution I thought, but using the Pool object. The hell.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">merge_sort_parallel_fastest</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">concurrentRoutine</span><span class="p">,</span> <span class="n">threaded</span><span class="p">):</span>

    <span class="c"># create a pool of concurrent threaded or process routine</span>
    <span class="k">if</span> <span class="n">threaded</span><span class="p">:</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPool</span><span class="p">(</span><span class="n">concurrentRoutine</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">concurrentRoutine</span><span class="p">)</span>

    <span class="c"># size of partitions</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">))</span> <span class="o">/</span> <span class="n">concurrentRoutine</span><span class="p">))</span>

    <span class="c"># partitioning</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">size</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">concurrentRoutine</span><span class="p">)]</span>

    <span class="c"># mapping each partition to one worker, using the standard merge sort</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="n">msort_sort</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="c"># go ahead until the number of partition are reduced to one (workers end respective ordering job)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

        <span class="c"># extra partition if there's a odd number of worker</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">None</span>

        <span class="c"># prepare couple of ordered partition for merging</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">2</span><span class="p">)]</span>

        <span class="c"># use the same number of worker to merge partitions</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="n">msort_merge</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="p">([</span><span class="n">extra</span><span class="p">]</span> <span class="k">if</span> <span class="n">extra</span> <span class="k">else</span> <span class="p">[])</span>

    <span class="c"># return result</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></code></pre></figure>

<p>And this perform better. The question is better using Threads or Processes? Well… look at my comparative graph!</p>

<p align="center"><img src="http://image.ibb.co/kHjz6w/mergesort.png" style="width: 100%; marker-top: -10px;" /></p>

<p>Ok, because Python version is not so good, this is a graph with only GoLang series:</p>

<p align="center"><img src="http://image.ibb.co/gG7VDb/gomerge.png" style="width: 100%; marker-top: -10px;" /></p>

<h3 id="conclusion">Conclusion</h3>
<p>Python sucks. GoLang rulez. I’m sorry, Python: I loved you. The complete code is available here: <a href="https://made2591.github.io/posts/go-py-benchmark">go-py-benchmark</a>.</p>

<p>Thank you everybody for reading!</p>

<div class="footnotes">
  <ol>
    <li id="fn:talk">
      <p>There are plenty of beautiful <a href="https://talks.golang.org/2012/concurrency.slide">slides</a> of a GoLang talk online!&nbsp;<a href="#fnref:talk" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:rob">
      <p>The lesson of <a href="https://vimeo.com/49718712">Rob Pike - Concurrency Is Not Parallelism</a>.&nbsp;<a href="#fnref:rob" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:docr">
      <p>Directly from the the official <a href="https://golang.org/doc/faq">FAQ</a> page.&nbsp;<a href="#fnref:docr" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:docc">
      <p>More info <a href="https://golang.org/ref/spec#Channel_types">here</a>.&nbsp;<a href="#fnref:docc" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:s1">
      <p>Source <a href="https://medium.com/@_orcaman/when-too-much-concurrency-slows-you-down-golang-9c144ca305a">here</a>&nbsp;<a href="#fnref:s1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:nbcs">
      <p>Have a look <a href="https://gobyexample.com/non-blocking-channel-operations">here</a>&nbsp;<a href="#fnref:nbcs" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:wg">
      <p>Here more about <a href="https://golang.org/pkg/sync/#WaitGroup">WaitGroup</a>&nbsp;<a href="#fnref:wg" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>


<div class="comments">
   <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'made2591';

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

</div>

<hr/>


  
    <div class="post-navs row">
      
        <div class="col-md-6 post-nav">

          <h3 class="section-header">
            Older
            <span class="text-muted"> &middot; </span>
            <a href="/archive">View Archive (35)</a>
          </h3>

          <h2 class="post-title-link"><a href="/posts/elasticnas">Elasticsearch over My home Network Attached Storage</a></h2>
          <h3 id="introduction">Introduction</h3>
<p>I always owned a lot of hard drives: I don’t know why, I always used and still use to look for space to save my data. In the years, I started using disks, then I assembled a HP Proliant to be a Synology Based System - I don’t want to go the cloud because I’m stupid - and… in the last week, I decided to make order in a huge amount of files. The first thing you have to do when you are handling terabytes and terabytes of <strong>both</strong> well-ordered <strong>and</strong> <em>no-ordered-at-all</em> data is literaly pray that someone else, like a magician, or druid comes to you with a magic wand and fixes all the mess for free, in a way you do not know but you will like.
This article is the right one if you don’t want to pray, you really don’t believe in miracle but you still need to order your stuff. I have done it using elastisearch and kibana!</p>


        </div>
      
      

        <div class="col-md-6 post-nav">
          <h3 class="section-header">
            Newer
            
          </h3>

          <h2 class="post-title-link"><a href="/posts/network-layers-2">A journey through the network - Layer 2</a></h2>
          <h3 id="a-journey-through-the-network---layer-2">A journey through the network - Layer 2</h3>
<p>A month ago I started to wrote some posts about the network. For those who missed the previous posts, <a href="https://made2591.github.io/posts/network-layers-0">the introduction</a> and <a href="https://made2591.github.io/posts/network-layers-0">the physycal layer</a>. For the previous post I had to go into details about how some parts of the physical layer work but, by going forward with the layers, concepts belonging to separate historical standards - OSI and IP - will intertwine and this entails some troubles from a <em>logical</em> point of view. I will try, as far as possible, to keep only the basic concepts of this layer: I also remember that this layer, together with the physical layer, are - at least in part - joined together in what is called the network access layer in the TCP / IP model.
As a main source I use <a href="https://www.amazon.it/gp/product/9332518742/ref=oh_aui_detailpage_o01_s00?ie=UTF8&amp;psc=1">Computer Networks</a> and <a href="https://www.amazon.it/gp/product/9332535957/ref=oh_aui_detailpage_o02_s00?ie=UTF8&amp;psc=1">TCP/IP Illustrated</a>. In this article, I will talk about layer 1, the data link layer in the ISO / OSI stack. Enjoy the reading!</p>


        </div>
      
    </div>
  



          <div id="footer">
<hr/>
  <div class="pull-left">
    &copy;2019.
    Built with <a href="http://jekyllrb.com/">Jekyll</a> and
    <a href="https://github.com/kirqe/autm-rb">Autm-rb</a>. Thanks to <a href="https://github.com/kirqe">kirqe</a>.
  </div>

  <div class="pull-right">
    <span class="credits pull-right social">
      
        
          <a href="https://github.com/made2591/" target="_blank"><i class="fa fa-github"></i></a>
        
      
        
          <a href="https://twitter.com/made2591" target="_blank"><i class="fa fa-twitter"></i></a>
        
      
        
          <a href="https://linkedin.com/in/mmadeddu" target="_blank"><i class="fa fa-linkedin"></i></a>
        
      
        
          <a href="https://www.facebook.com/matteo.madeddu" target="_blank"><i class="fa fa-facebook"></i></a>
        
      
    </span>
  </div>
</div>

        </section>
    </div>
    </div>
    <script src="/public/javascripts/jquery.min.js"></script>
    <script src="/public/javascripts/bootstrap.min.js"></script>
    <!-- Place your <script> tags here. -->

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<script id="dsq-count-scr" src="//made2591-github-io.disqus.com/count.js" async></script>

<!-- disqus comment counter -->
<script type="text/javascript">
	/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'made2591-github-io';

	/* * * DON'T EDIT BELOW THIS LINE * * */
	(function () {
	    var s = document.createElement('script'); s.async = true;
	    s.type = 'text/javascript';
	    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
	    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
	}());
</script>
<!-- /disqus comment counter -->

<!-- google analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111283556-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-111283556-1');
</script>
<!-- /google analytics -->

  </body>
</html>
